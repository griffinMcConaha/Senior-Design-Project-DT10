# Robotic Anti-Icing System (DT10) — Detailed Engineering README

This document is the detailed technical companion to `README.md`.

## 1) Mission and System Context

DT10 is an embedded robotic platform intended to apply anti-icing material while operating safely in outdoor environments. The firmware is designed around:

- Deterministic state-based control (`MANUAL`, `AUTO`, `PAUSE`, `ERROR`, `ESTOP`)
- Continuous sensor intake and fusion (IMU, GPS, proximity)
- Safety-first behavior (watchdog, health monitoring, emergency stop)
- Remote observability and command ingress (LoRa)

Target MCU/platform:

- STM32F407 (STM32CubeIDE/CubeMX project)

---

## 2) Full Repository Layout

Top-level structure:

- `.settings/` — STM32CubeIDE/Eclipse metadata
- `Core/` — Primary application code (source + headers)
- `Debug/` — Debug build artifacts generated by IDE
- `Release/` — Release build artifacts generated by IDE
- `Drivers/` — STM32 HAL + CMSIS middleware/vendor libraries
- `.cproject`, `.project`, `.mxproject` — IDE and toolchain project metadata
- `Robotic Anti-Icing System.ioc` — CubeMX peripheral/pin configuration source
- `STM32F407VGTX_FLASH.ld`, `STM32F407VGTX_RAM.ld` — linker scripts
- `LICENSE`
- `README.md` (short)
- `README_DETAILED.md` (this file)

`Core/Inc` header inventory:

- `console_io.h`
- `diagnostics.h`
- `dispersion.h`
- `gps.h`
- `heading_fusion.h`
- `i2c_utils.h`
- `imu_icm20948.h`
- `main.h`
- `mcu_protocol.h`
- `mission.h`
- `proximity.h`
- `robot_actions.h`
- `robot_sm.h`
- `sabertooth.h`
- `stm32f4xx_hal_conf.h`
- `stm32f4xx_it.h`
- `system_health.h`
- `uart_lora.h`

`Core/Src` source inventory:

- `main.c`
- `console_io.c`
- `diagnostics.c`
- `dispersion.c`
- `gps.c`
- `heading_fusion.c`
- `i2c_utils.c`
- `imu_icm20948.c`
- `mission.c`
- `proximity.c`
- `robot_actions.c`
- `robot_sm.c`
- `sabertooth.c`
- `stm32f4xx_hal_msp.c`
- `stm32f4xx_it.c`
- `syscalls.c`
- `sysmem.c`
- `system_health.c`
- `system_stm32f4xx.c`
- `uart_lora.c`

---

## 3) Software Architecture

The architecture is modular C with explicit interfaces and centralized orchestration in `main.c`.

Primary layers:

1. **Platform/HAL layer**
   - Startup, clocks, GPIO, timers, UART, I2C, interrupts
2. **Device/driver layer**
   - IMU, GPS parser, proximity sensor timing, Sabertooth, LoRa, dispersion
3. **Control layer**
   - State machine + action dispatch + heading fusion
4. **Safety and diagnostics layer**
   - Health monitor, watchdog discipline, diagnostic command/test functions

Design intent:

- Keep hardware-specific logic mostly in module drivers.
- Keep policy and control flow in state/action modules.
- Keep fault and safety decisions centralized in `system_health` and state transitions.

---

## 4) Boot Sequence and Runtime Flow

### Boot sequence (high-level)

1. HAL and peripherals initialize (I2C/UART/SPI/TIM/GPIO, etc.)
2. Console and serial routing initialize
3. I2C scan validates bus/device presence
4. System health monitor initializes
5. Hardware watchdog initializes
6. Core modules initialize (IMU, state machine, heading fusion, drivetrain, proximity, dispersion, LoRa, mission)
7. IMU calibration executes (watchdog-safe, bounded timeout)
8. GPS short fix wait period
9. System enters main loop

### Main loop behavior

- Watchdog refresh at loop level
- Console command polling
- Periodic IMU + fusion updates
- Safety check and state transition handling
- State-specific action dispatch
- LoRa periodic task and telemetry updates

---

## 5) Key Module Responsibilities

### `main.c`

- System bootstrap, scheduler cadence, and integration of all modules
- Boot-time calibration/wait behavior
- Runtime loop and periodic task orchestration

### `robot_sm.c` + `robot_actions.c`

- Explicit state transitions and fault-aware flow control
- Action handlers for manual/autonomous/error/estop behavior

### `imu_icm20948.c`

- ICM-20948 init, read, calibration, optional AK09916 mag handling
- Uses short I2C timeout strategy to avoid long blocking under bus faults

### `heading_fusion.c`

- Combines inertial + GPS information into fused heading/attitude outputs
- Produces confidence-weighted navigation orientation values

### `gps.c`

- NMEA sentence parsing and fix/quality data extraction
- Stale/freshness tracking window for control safety

### `proximity.c`

- HC-SR04 trigger/echo timing and filtering
- No-detection semantics and baseline false-echo handling
- Effective max range policy currently capped in software at 250 cm

### `system_health.c`

- Sensor health state bookkeeping and transition triggers
- Emergency-stop trigger/reset gating behavior

### `diagnostics.c` + `console_io.c`

- Human-operated diagnostic and test interfaces
- Continuous tests with watchdog refresh discipline

### `uart_lora.c`

- Telemetry uplink + command ingestion over LoRa
- Periodic health-linked status updates

### `sabertooth.c`

- Motor command and feedback interface abstraction

### `dispersion.c`

- Salt/brine actuator control and state/monitor support

---

## 6) Safety Model

Safety mechanisms include:

- **Hardware watchdog** to recover from hangs/deadlocks
- **State machine constraints** to prevent unsafe transitions
- **Health monitor** to detect degraded/failed sensor conditions
- **Emergency stop path** with motor stop and latched safety behavior

Operational policy examples reflected in codebase:

- IMU/GPS health influences transition and reset behavior
- Blocking loops in diagnostics are watchdog-aware
- Sensor stale/timeout states feed status and control decisions

---

## 7) Timing and Real-Time Considerations

- Control loop uses periodic scheduling in the main loop.
- IMU and sensor operations are tuned to reduce blocking risk.
- I2C timeout bounds are kept short to prevent control starvation during bus faults.
- Proximity timing and filtering are tuned for robust behavior rather than maximum raw range.

When modifying timing-critical code:

- Preserve watchdog refresh opportunities.
- Avoid unbounded busy-waits.
- Keep per-cycle worst-case latency bounded.

---

## 8) Build, Flash, and Tooling

Build workflow:

1. Open project in STM32CubeIDE.
2. If pin/peripheral map changed, regenerate from `.ioc`.
3. Build target (`Debug` or `Release`).
4. Flash with ST-Link.

Artifacts and generated outputs:

- Do not treat `Debug/` and `Release/` as source-of-truth for logic.
- Source-of-truth remains under `Core/` and configuration files.

---

## 9) Developer Workflow Recommendations

- Branch from `main` for feature/fix work.
- Keep commits module-focused (sensor, safety, comms, etc.).
- Run diagnostics before and after hardware-facing changes.
- Document non-obvious tuning constants and thresholds.

Suggested commit categories:

- `safety:` watchdog, estop, health logic
- `control:` state machine/actions/fusion
- `drivers:` IMU/GPS/proximity/sabertooth/lora/dispersion
- `docs:` README and interface docs

---

## 10) Known System Constraints

- Proximity effective range is intentionally software-capped to improve reliability.
- Sensor readings and communication quality are environment-dependent.
- Calibration quality and board stability directly affect heading/attitude accuracy.

---

## 11) Suggested Next Documentation Improvements

If desired, this detailed README can be split into:

- `docs/ARCHITECTURE.md` (module interactions + diagrams)
- `docs/SAFETY.md` (fault model, estop policy, watchdog)
- `docs/BRINGUP.md` (first power-on checklist)
- `docs/TUNING.md` (thresholds, filters, timing constants)

---

## 12) Repository

Primary repository:

https://github.com/griffinMcConaha/Senior-Design-Project-DT10